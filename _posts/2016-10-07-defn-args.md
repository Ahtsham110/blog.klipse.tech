---
layout: post
title:  "Custom defn macro with clojure.spec - part 1: conform/unform"
description:  "Custom defn macro with clojure.spec - part 1: conform/unform. parsers. ast. abstract syntax tree."
date:   2016-10-09 06:11:22 +0200
categories: clojure
thumbnail: assets/klipse.png
guid: "B58ADE6B-02B1-496C-BB95-CFAC28F4A307"
draft: true
hidden: true
author: "@viebel"
---

# Introduction


With `clojure.spec`, we can validate function/macors arguments and we can also parse them into kind of an Abstract Syntax Tree (AST).

In this two-part series, we are going to show how one can write his custom `defn`-like macro.


In this part, we are going to show how one can parse the arguments of the `defn` macro, modifies the parse tree and convert it back to the format `defn` expects.

In the second part, we will use this idea to write a couple of custom `defn` like macros:

- `defdoc`: automatic enrichment of docstring
- `defprint`: automatic logging of function calls
- `deftry`: automatic catching of exceptions

![Tree](/assets/tree.jpg)

# conform and unform

The basic idea of this article is based on the fact that in `clojure.spec`, `conform` and `unform` are reciprocical.

Here is the documentation of `unform`:

~~~
Usage: (unform spec x)
Given a spec and a value created by or compliant with a call to
'conform' with the same spec, returns a value with all conform
destructuring undone.
~~~

In other words: `(unform spec (conform spec x))` is equal to `x`.


Let's play with conform/unform with a simple spec - that receives a list that contains two elements:

1. either a string or a keyword
2. a number

~~~klipse
    (ns my.spec
        (:require [clojure.spec :as s]))
~~~


~~~klipse
(s/def ::str-or-kw (s/alt :str string?
                          :kw  keyword?))

(s/def ::my-spec (s/cat
                   :first ::str-or-kw
                   :second number?))
~~~


Let's look how `conform` destrucutres valid input:

~~~klipse
(s/conform ::my-spec '(:a 1))
~~~

And when we call `unform`, we get the original data back:

~~~klipse
(->> (s/conform ::my-spec '(:a 1))
     (s/unform ::my-spec))
~~~

# Catches with conform/unform

Sometimes `conform` and `unform` are not fully inlined.

Take a look at this:

~~~klipse
(->> (s/conform ::my-spec [:a 1])
     (s/unform ::my-spec))
~~~

`[:a 1]` is a valid `::my-spec` but it is unformed as a list and not as a vector.

One way to fix that is to use `spec/conformer`, like this:

~~~klipse
(s/def ::str-or-kw (s/alt :str string?
                          :kw  keyword?))

(s/def ::my-spec-vec (s/and vector?
                        (s/conformer vec vec)
                                                (s/cat
                                                                          :first ::str-or-kw
                                                                                                    :second number?)))
~~~


~~~klipse
(->> (s/conform ::my-spec-vec [:a 1])
     (s/unform ::my-spec-vec))
~~~

Now, let's move to the `defn` stuff...

# args of defn macro

The `spec` for `defn` arguments is called `:defn-args` and it is defined in [clojure.core.specs namespace](https://github.com/clojure/clojure/blob/clojure-1.9.0-alpha13/src/clj/clojure/core/specs.clj#L78-L84). 

But there are two problems with this implementation:

1. It has [not yet been ported](http://dev.clojure.org/jira/browse/CLJS-1813) to `clojurescript`

2. `unform` and `conform` are not fully inlined  (`unform` returns lists instead of vectors).


Here is the full spec for `:defn-args` where unform and conform are inlined. This code is inspired form Mark Engleberg [better-cond repo](https://github.com/Engelberg/better-cond).

Feel free to skip this code snippet - and go back to it later:

<pre>
<code class="language-klipse" data-gist-id="viebel/ab64ed95820af42b366889a872dc28ac"></code></pre>

Let's see `::defn-args` in action.

First, with a simple function `foo`:

~~~klipse
(s/conform ::defn-args '(foo [[a b]] (+ a b)))
~~~


And now, with a multi-arity function that provides a docstring and meta data.

~~~klipse
(s/conform ::defn-args '(bar "bar is a multi-arity function" {:private true} ([a b] (+ a b)) ([] (foo 1 1))))
~~~

The cool thing is that we can manipulate the AST - returned by conform. For instance, we can modify the docstring:

~~~klipse
(def the-new-args-ast 
  (-> (s/conform ::defn-args '(bar "bar is a multi-arity function" {:private true} ([a b] (+ a b)) ([] (foo 1 1))))
        (assoc :docstring "bar has a cool docstring")))
~~~


And if we unform it, we get: 

~~~klipse
(s/unform ::defn-args the-new-args-ast)
~~~

We can now, create a `defn` statement with the modified arguments:

~~~klipse
(cons `defn (s/unform ::defn-args the-new-args-ast))
~~~


In our next article, we will use those ideas to create custom `defn` like macros.

- `defdoc`: automatic enrichment of docstring
- `defprint`: automatic logging of function calls
- `deftry`: automatic catching of exceptions

Clojure rocks!

